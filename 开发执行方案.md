

### 开发执行方案（基于已确认需求）

---

#### 一、技术栈确认
| 模块 | 技术方案 | 版本/配置 |
|------|----------|-----------|
| 框架 | Next.js (App Router) | 14.x |
| UI库 | Shadcn/UI + Tailwind CSS | 最新版 |
| 上传 | react-dropzone | 14.x |
| 音频处理 | @ffmpeg/ffmpeg | 0.12.10 |
| 部署 | Vercel | 免费套餐测试 |

---

#### 二、关键实现细节

##### 1. 文件上传组件（react-dropzone + Shadcn/UI）
```tsx
// components/FileUploader.tsx
import { useCallback, useState } from 'react';
import { useDropzone } from 'react-dropzone';
import { Card, CardContent } from '@/components/ui/card';
import { Button } from '@/components/ui/button';

const MAX_SIZE = 100 * 1024 * 1024; // 100MB
const VALID_TYPES = ['.opus', '.ogg', '.webm'];

export function FileUploader({ onFileSelect }: { onFileSelect: (file: File) => void }) {
  const [error, setError] = useState<string>('');
  const [fileSize, setFileSize] = useState<number>(0);

  const onDrop = useCallback((acceptedFiles: File[]) => {
    const file = acceptedFiles[0];
    if (!file) return;

    // 类型校验
    const isValidType = VALID_TYPES.some(ext => 
      file.name.toLowerCase().endsWith(ext)
    );
    if (!isValidType) {
      setError('仅支持 .opus, .ogg, .webm 格式');
      return;
    }

    // 大小校验
    if (file.size > MAX_SIZE) {
      setError(`文件大小超过 ${MAX_SIZE/1024/1024}MB 限制`);
      return;
    }

    setError('');
    setFileSize(file.size);
    onFileSelect(file);
  }, []);

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept: {
      'audio/*': VALID_TYPES
    },
    maxSize: MAX_SIZE,
    multiple: false
  });

  return (
    <Card className="w-full max-w-md mx-auto">
      <CardContent className="p-6">
        <div
          {...getRootProps()}
          className={`border-2 border-dashed rounded-lg p-8 text-center cursor-pointer transition-colors ${
            isDragActive ? 'border-blue-500 bg-blue-50' : 'border-gray-300'
          }`}
        >
          <input {...getInputProps()} />
          <p className="text-gray-600">
            {isDragActive ? '松开以上传文件' : '拖拽文件到此处，或点击选择'}
          </p>
          {fileSize > 0 && (
            <p className="text-sm text-green-600 mt-2">
              已选择: {(fileSize/1024/1024).toFixed(2)}MB
            </p>
          )}
        </div>
        {error && <p className="text-red-500 text-sm mt-2">{error}</p>}
      </CardContent>
    </Card>
  );
}
```

##### 2. ffmpeg.wasm 核心逻辑（懒加载 + 进度）
```tsx
// lib/ffmpeg.ts
import { FFmpeg } from '@ffmpeg/ffmpeg';
import { fetchFile } from '@ffmpeg/util';

export class AudioConverter {
  private ffmpeg: FFmpeg;
  private isLoaded = false;

  constructor() {
    this.ffmpeg = new FFmpeg();
    this.setupProgress();
  }

  private setupProgress() {
    this.ffmpeg.on('progress', ({ progress }) => {
      // 通过事件总线通知UI更新
      window.dispatchEvent(new CustomEvent('ffmpeg-progress', {
        detail: Math.round(progress * 100)
      }));
    });
  }

  async load() {
    if (!this.isLoaded) {
      await this.ffmpeg.load();
      this.isLoaded = true;
    }
  }

  async convert(file: File, bitrate = '192k'): Promise<Blob> {
    const inputName = 'input' + file.name.substring(file.name.lastIndexOf('.'));
    const outputName = 'output.mp3';

    // 写入文件
    await this.ffmpeg.writeFile(inputName, await fetchFile(file));
    
    // 执行转换
    await this.ffmpeg.exec([
      '-i', inputName,
      '-b:a', bitrate,
      outputName
    ]);

    // 读取输出
    const data = await this.ffmpeg.readFile(outputName);
    return new Blob([data], { type: 'audio/mpeg' });
  }

  terminate() {
    this.ffmpeg.terminate();
    this.isLoaded = false;
  }
}
```

##### 3. 主页面组件（完整流程）
```tsx
// app/page.tsx
'use client';

import { useState, useEffect, useRef } from 'react';
import { FileUploader } from '@/components/FileUploader';
import { Button } from '@/components/ui/button';
import { Progress } from '@/components/ui/progress';
import { Collapsible, CollapsibleContent, CollapsibleTrigger } from '@/components/ui/collapsible';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { AudioConverter } from '@/lib/ffmpeg';

export default function Home() {
  const [file, setFile] = useState<File | null>(null);
  const [progress, setProgress] = useState(0);
  const [loading, setLoading] = useState(false);
  const [loadingMessage, setLoadingMessage] = useState('');
  const [downloadUrl, setDownloadUrl] = useState<string>('');
  const [bitrate, setBitrate] = useState('192k');
  const converterRef = useRef<AudioConverter | null>(null);

  // 初始化转换器
  useEffect(() => {
    converterRef.current = new AudioConverter();
    
    // 监听进度事件
    const handleProgress = (e: Event) => {
      setProgress((e as CustomEvent).detail);
    };
    window.addEventListener('ffmpeg-progress', handleProgress);

    return () => {
      window.removeEventListener('ffmpeg-progress', handleProgress);
      converterRef.current?.terminate();
    };
  }, []);

  const handleConvert = async () => {
    if (!file || !converterRef.current) return;

    setLoading(true);
    setLoadingMessage('正在初始化转换引擎...');
    setProgress(0);

    try {
      // 懒加载ffmpeg
      await converterRef.current.load();
      setLoadingMessage('');

      // 执行转换
      const blob = await converterRef.current.convert(file, bitrate);
      const url = URL.createObjectURL(blob);
      setDownloadUrl(url);
    } catch (error) {
      console.error('转换失败:', error);
      alert('转换失败，请重试');
    } finally {
      setLoading(false);
    }
  };

  return (
    <main className="min-h-screen bg-gray-50 py-12 px-4">
      <div className="max-w-2xl mx-auto">
        <h1 className="text-3xl font-bold text-center mb-8">QuickOpus2MP3</h1>
        
        <FileUploader onFileSelect={setFile} />

        {file && (
          <Card className="mt-6">
            <CardHeader>
              <CardTitle>转换设置</CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              {/* 高级设置 */}
              <Collapsible>
                <CollapsibleTrigger asChild>
                  <Button variant="outline" className="w-full">
                    高级设置
                  </Button>
                </CollapsibleTrigger>
                <CollapsibleContent className="mt-4">
                  <div>
                    <label className="block text-sm font-medium mb-2">
                      比特率
                    </label>
                    <div className="flex space-x-2">
                      {['128k', '192k', '320k'].map((rate) => (
                        <Button
                          key={rate}
                          variant={bitrate === rate ? 'default' : 'outline'}
                          onClick={() => setBitrate(rate)}
                          size="sm"
                        >
                          {rate}
                        </Button>
                      ))}
                    </div>
                  </div>
                </CollapsibleContent>
              </Collapsible>

              {/* 转换按钮 */}
              <Button 
                onClick={handleConvert} 
                disabled={loading}
                className="w-full"
              >
                {loading ? '转换中...' : '开始转换'}
              </Button>

              {/* 进度显示 */}
              {loading && (
                <div className="space-y-2">
                  <div className="text-sm text-gray-600">
                    {loadingMessage || `转换中：${progress}%`}
                  </div>
                  <Progress value={progress} />
                </div>
              )}

              {/* 下载按钮 */}
              {downloadUrl && (
                <div className="pt-4">
                  <a
                    href={downloadUrl}
                    download="converted.mp3"
                    className="inline-block w-full"
                  >
                    <Button className="w-full">下载 MP3</Button>
                  </a>
                </div>
              )}
            </CardContent>
          </Card>
        )}
      </div>
    </main>
  );
}
```

##### 4. next.config.js 配置
```javascript
// next.config.js
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    asyncWebAssembly: true,
  },
  webpack: (config) => {
    // 解决 ffmpeg.wasm 的 Node.js 模块依赖问题
    config.resolve.fallback = { 
      fs: false, 
      path: false,
      os: false
    };
    return config;
  },
};

module.exports = nextConfig;
```

---

#### 三、测试验证计划

##### 1. 本地测试
```bash
# 启动开发服务器
npm run dev

# 测试用例：
1. 上传 5MB .opus 文件 → 验证转换和下载
2. 上传 100MB .opus 文件 → 验证内存占用和进度
3. 尝试上传 101MB 文件 → 验证大小限制
4. 上传 .mp3 文件 → 验证格式拒绝
5. 测试拖拽上传功能
6. 测试高级设置（比特率切换）
```

##### 2. Vercel 部署测试
1. 推送代码到 GitHub
2. Vercel 导入项目并部署
3. 重复本地测试用例
4. 重点验证 100MB 文件上传：
   ```bash
   # 使用 curl 测试大文件上传
   curl -X POST -F "file=@large.opus" [部署URL]
   ```

##### 3. 性能监控指标
| 指标 | 目标值 | 测试方法 |
|------|--------|----------|
| 首屏加载时间 | <3s | Lighthouse 测试 |
| ffmpeg 初始化时间 | <5s | 控制台日志 |
| 100MB 文件转换时间 | <60s | 实际测试 |
| 内存峰值 | <500MB | Chrome DevTools |

---

#### 四、部署后优化建议

1. **CDN 加速**：
   ```javascript
   // 在 _document.tsx 中预加载 ffmpeg.wasm
   <script 
     src="https://unpkg.com/@ffmpeg/core@0.12.6/dist/ffmpeg-core.js" 
     strategy="beforeInteractive"
   />
   ```

2. **错误边界增强**：
   ```tsx
   // 添加错误边界组件
   class ErrorBoundary extends React.Component {
     static getDerivedStateFromError(error) {
       return { hasError: true };
     }
     componentDidCatch(error, info) {
       // 上报错误到 Sentry
     }
   }
   ```

3. **大文件处理优化**：
   ```tsx
   // 添加转换取消功能
   const abortController = useRef(new AbortController());
   
   const handleCancel = () => {
     abortController.current.abort();
     converterRef.current?.terminate();
   };
   ```

---

#### 五、交付物清单
1. 完整 Next.js 项目代码
2. Vercel 部署链接
3. 测试报告（包含 100MB 文件测试结果）
4. 性能优化建议文档

开发过程中将严格遵循文档需求，遇到技术瓶颈会及时沟通。预计开发周期：4天（含测试优化）。